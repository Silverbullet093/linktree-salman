<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Finger Count Particle System - Manual & Auto</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        .input_video { display: none; }
        
        #ui-layer {
            position: absolute; top: 30px; left: 50%; transform: translateX(-50%);
            z-index: 10; text-align: center; color: white; pointer-events: none;
            background: rgba(0,0,0,0.5); padding: 15px 30px; border-radius: 30px;
            backdrop-filter: blur(5px); border: 1px solid rgba(255,255,255,0.2);
        }
        h1 { margin: 0; font-size: 1.2rem; letter-spacing: 1px; color: #aaa; }
        #status-display { 
            font-size: 2rem; font-weight: bold; margin-top: 5px; 
            background: -webkit-linear-gradient(#00ffff, #0077ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-size: 1.2rem; pointer-events: none; z-index: 20;
        }
        
        .guide {
            position: absolute; bottom: 30px; left: 30px; color: rgba(255,255,255,0.6); z-index: 10;
            font-size: 0.9rem; line-height: 1.6; pointer-events: none;
        }

        /* Indikator area klik (opsional, agar user tahu) */
        .click-zone {
            position: absolute; top: 0; width: 50%; height: 100%; z-index: 5;
            cursor: pointer;
        }
        #left-zone { left: 0; }
        #right-zone { right: 0; }
        
        /* Efek hover visual */
        .click-zone:hover { background: rgba(255,255,255,0.02); }
        .click-zone:active { background: rgba(255,255,255,0.05); }
    </style>
</head>
<body>

    <div id="loading">Memuat Pendeteksi Jari...</div>
    
    <div id="ui-layer">
        <h1>BENTUK PARTIKEL</h1>
        <div id="status-display">Menunggu Tangan...</div>
    </div>

    <div id="left-zone" class="click-zone" title="Klik Kiri: Mundur"></div>
    <div id="right-zone" class="click-zone" title="Klik Kanan: Maju"></div>

    <div class="guide">
        <b>Kontrol Manual:</b><br>
        ‚¨ÖÔ∏è Klik Kiri: Sebelumnya<br>
        ‚û°Ô∏è Klik Kanan: Selanjutnya<br>
        <hr style="border-color: rgba(255,255,255,0.2)">
        <b>Kontrol Tangan:</b><br>
        ‚úä 0 : Adalah pokoknya <br>
        ‚òùÔ∏è 1 : Sphere<br>
        ‚úåÔ∏è 2 : Heart<br>
        ü§ü 3 : Saturn<br>
        üññ 4 : Flower<br>
        üñê 5 : Galaxy
    </div>

    <div id="canvas-container"></div>
    <video class="input_video"></video>

    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';
        import { OrbitControls } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/controls/OrbitControls.js';
        
        const loadScript = (src) => {
            return new Promise((resolve, reject) => {
                const s = document.createElement('script');
                s.src = src;
                s.onload = resolve;
                s.onerror = reject;
                document.head.appendChild(s);
            });
        };

        (async function initApp() {
            await loadScript('https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js');
            await loadScript('https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js');
            await loadScript('https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js');
            await loadScript('https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js');

            const loadingEl = document.getElementById('loading');
            const statusEl = document.getElementById('status-display');
            
            // --- THREE.JS SETUP ---
            const scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.02); 

            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 35; 

            const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            const controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.8; 

            // --- PARTICLE SYSTEM ---
            const particleCount = 20000; 
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const targetPositions = new Float32Array(particleCount * 3);
            
            const colors = {
                text: new THREE.Color(0xA020F0), // Ungu
                sphere: new THREE.Color(0x00ff88),
                heart: new THREE.Color(0xff0055),
                saturn: new THREE.Color(0xffaa00),
                flower: new THREE.Color(0xff00ff),
                galaxy: new THREE.Color(0x00ffff)
            };

            for(let i=0; i<particleCount*3; i++) {
                positions[i] = (Math.random() - 0.5) * 50;
                targetPositions[i] = positions[i];
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

            const material = new THREE.PointsMaterial({
                size: 0.2, 
                color: 0x00ff88,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            const particles = new THREE.Points(geometry, material);
            scene.add(particles);

            // --- FUNGSI GENERATOR KOORDINAT TEKS ---
            function createTextCoordinates(text) {
                const canvas = document.createElement('canvas');
                const width = 800; 
                const height = 200;
                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext('2d');

                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, width, height);
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 130px Arial'; 
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(text, width / 2, height / 2);

                const imageData = ctx.getImageData(0, 0, width, height);
                const data = imageData.data;
                const coords = [];

                for (let y = 0; y < height; y += 2) { 
                    for (let x = 0; x < width; x += 2) {
                        const index = (y * width + x) * 4;
                        if (data[index] > 128) {
                            coords.push({
                                x: (x - width / 2) * 0.08, 
                                y: -(y - height / 2) * 0.08, 
                                z: 0
                            });
                        }
                    }
                }
                return coords;
            }

            const textPoints = createTextCoordinates("slamander");

            // --- RUMUS BENTUK ---
            const shapes = {
                text: (i) => { // 0 Jari
                    if (textPoints.length === 0) return { x: 0, y: 0, z: 0 };
                    const p = textPoints[i % textPoints.length];
                    return { x: p.x + (Math.random()-0.5)*0.15, y: p.y + (Math.random()-0.5)*0.15, z: p.z + (Math.random()-0.5)*1.5 };
                },
                sphere: (i) => { // 1 Jari
                    const r = 11;
                    const phi = Math.acos(-1 + (2 * i) / particleCount);
                    const theta = Math.sqrt(particleCount * Math.PI) * phi;
                    return { x: r * Math.cos(theta) * Math.sin(phi), y: r * Math.sin(theta) * Math.sin(phi), z: r * Math.cos(phi) };
                },
                heart: (i) => { // 2 Jari
                    const t = (i / particleCount) * Math.PI * 2; 
                    const x = 16 * Math.pow(Math.sin(t), 3);
                    const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                    return { x: x * 0.6, y: y * 0.6, z: (Math.random()-0.5) * 4 };
                },
                saturn: (i) => { // 3 Jari
                    if (i < particleCount * 0.4) {
                        const r = 6;
                        const phi = Math.acos(-1 + (2 * i) / (particleCount*0.4));
                        const theta = Math.sqrt((particleCount*0.4) * Math.PI) * phi;
                        return { x: r * Math.cos(theta) * Math.sin(phi), y: r * Math.sin(theta) * Math.sin(phi), z: r * Math.cos(phi) };
                    } else {
                        const angle = i * 0.02;
                        const r = 10 + Math.random() * 6;
                        return { x: Math.cos(angle) * r, y: (Math.random()-0.5)*0.5, z: Math.sin(angle) * r };
                    }
                },
                flower: (i) => { // 4 Jari
                    const u = Math.random() * Math.PI * 2;
                    const v = Math.random() * Math.PI;
                    const r = 6 + 4 * Math.sin(6 * u) * Math.sin(6 * v);
                    return { x: r * Math.sin(v) * Math.cos(u), y: r * Math.sin(v) * Math.sin(u), z: r * Math.cos(v) };
                },
                galaxy: (i) => { // 5 Jari
                    const angle = i * 0.1;
                    const r = 0.1 * i * 0.05; 
                    return { x: Math.cos(angle) * r * 7 + (Math.random()-0.5), y: (Math.random() - 0.5) * 3, z: Math.sin(angle) * r * 7 + (Math.random()-0.5) };
                }
            };

            // --- LOGIKA NAVIGASI ---
            const shapeList = ['text', 'sphere', 'heart', 'saturn', 'flower', 'galaxy'];
            let currentShapeIndex = 1; // Default ke sphere
            let currentShape = 'sphere';
            
            function updateShape(shapeName) {
                if(currentShape === shapeName) return; 
                currentShape = shapeName;

                const generator = shapes[shapeName];

                for (let i = 0; i < particleCount; i++) {
                    const pos = generator(i);
                    targetPositions[i * 3] = pos.x;
                    targetPositions[i * 3 + 1] = pos.y;
                    targetPositions[i * 3 + 2] = pos.z;
                }
                
                // Transisi Warna Halus
                const targetColor = colors[shapeName] || colors.sphere;
                new TWEEN.Tween(material.color)
                    .to({ r: targetColor.r, g: targetColor.g, b: targetColor.b }, 500)
                    .easing(TWEEN.Easing.Quadratic.Out)
                    .start();
            }
            
            updateShape('sphere');

            // --- INPUT MANUAL (TAP KANAN/KIRI) ---
            window.addEventListener('pointerdown', (event) => {
                const width = window.innerWidth;
                const clickX = event.clientX;

                if (clickX > width / 2) {
                    // Klik Kanan: Next
                    currentShapeIndex = (currentShapeIndex + 1) % shapeList.length;
                } else {
                    // Klik Kiri: Previous
                    currentShapeIndex = (currentShapeIndex - 1 + shapeList.length) % shapeList.length;
                }

                const newShape = shapeList[currentShapeIndex];
                
                // Format label manual agar terlihat rapi (kapitalisasi huruf pertama)
                const label = newShape.charAt(0).toUpperCase() + newShape.slice(1);
                statusEl.innerText = "Manual: " + (newShape === 'text' ? 'Adalah Pokoknya' : label);
                
                updateShape(newShape);
            });

            // --- LOGIKA HITUNG JARI ---
            function countFingers(landmarks) {
                let count = 0;
                const fingerIndices = [8, 12, 16, 20];
                
                fingerIndices.forEach(tipIdx => {
                    const pipIdx = tipIdx - 2; 
                    if (landmarks[tipIdx].y < landmarks[pipIdx].y) {
                        count++;
                    }
                });

                const thumbTip = landmarks[4];
                const thumbIP = landmarks[3];
                const pinkyMCP = landmarks[17];
                
                if (Math.abs(thumbTip.x - pinkyMCP.x) > Math.abs(thumbIP.x - pinkyMCP.x)) {
                    count++;
                }
                return count;
            }

            // --- MEDIA PIPE HANDS ---
            const videoElement = document.getElementsByClassName('input_video')[0];

            function onResults(results) {
                loadingEl.style.display = 'none';

                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    const landmarks = results.multiHandLandmarks[0];
                    const fingers = countFingers(landmarks);

                    let shapeName = 'sphere';
                    let label = "Mengepal";

                    // LOGIKA TANGAN
                    if (fingers === 0) { shapeName = 'text'; label = "‚úä Adalah Pokoknya"; }
                    else if (fingers === 1) { shapeName = 'sphere'; label = "1 Jari: Bola"; }
                    else if (fingers === 2) { shapeName = 'heart'; label = "2 Jari: Jantung"; }
                    else if (fingers === 3) { shapeName = 'saturn'; label = "3 Jari: Saturnus"; }
                    else if (fingers === 4) { shapeName = 'flower'; label = "4 Jari: Bunga"; }
                    else if (fingers === 5) { shapeName = 'galaxy'; label = "5 Jari: Galaxy"; }

                    // SINKRONISASI: Jika tangan terdeteksi, update index manual agar tidak lompat
                    currentShapeIndex = shapeList.indexOf(shapeName);

                    statusEl.innerText = label;
                    updateShape(shapeName);
                } else {
                    // Jika tidak ada tangan, biarkan user mengontrol manual (jangan di-reset teksnya)
                    if (statusEl.innerText === "Menunggu Tangan...") {
                         statusEl.innerText = "Ketuk Layar (Manual)";
                    }
                }
            }

            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });
            hands.onResults(onResults);

            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => { await hands.send({image: videoElement}); },
                width: 640, height: 480
            });
            cameraUtils.start();

            // --- ANIMATION LOOP & TWEEN ---
            const clock = new THREE.Clock();
            
            const TWEEN = {
                tweens: [],
                getAll: function() { return this.tweens; },
                removeAll: function() { this.tweens = []; },
                add: function(tween) { this.tweens.push(tween); },
                remove: function(tween) { 
                    const i = this.tweens.indexOf(tween); 
                    if(i!==-1) this.tweens.splice(i,1); 
                },
                update: function(time) {
                    if(this.tweens.length === 0) return false;
                    let i = 0;
                    while(i < this.tweens.length) {
                        if(this.tweens[i].update(time)) i++;
                        else this.tweens.splice(i, 1);
                    }
                    return true;
                }
            };
            
            TWEEN.Tween = function(object) {
                this.object = object;
                this.valuesStart = {};
                this.valuesEnd = {};
                this.duration = 1000;
                this.startTime = null;
                this.easingFunction = (k) => k; 
            };
            TWEEN.Tween.prototype = {
                to: function(properties, duration) {
                    this.valuesEnd = properties;
                    if(duration !== undefined) this.duration = duration;
                    return this;
                },
                start: function() {
                    this.startTime = performance.now();
                    for(const property in this.valuesEnd) {
                        this.valuesStart[property] = parseFloat(this.object[property]);
                    }
                    TWEEN.add(this);
                    return this;
                },
                easing: function(easing) { this.easingFunction = easing; return this; },
                update: function(time) {
                    let t = (performance.now() - this.startTime) / this.duration;
                    if(t > 1) t = 1;
                    const value = this.easingFunction(t);
                    for(const property in this.valuesEnd) {
                        const start = this.valuesStart[property];
                        const end = this.valuesEnd[property];
                        this.object[property] = start + (end - start) * value;
                    }
                    if(t === 1) return false;
                    return true;
                }
            };
            TWEEN.Easing = { Quadratic: { Out: (k) => k * (2 - k) } };

            function animate() {
                requestAnimationFrame(animate);
                TWEEN.update(); 
                
                const time = clock.getElapsedTime();
                const positionsAttr = geometry.attributes.position;
                const currentPos = positionsAttr.array;

                for (let i = 0; i < particleCount; i++) {
                    const ix = i * 3;
                    currentPos[ix] += (targetPositions[ix] - currentPos[ix]) * 0.08;
                    currentPos[ix+1] += (targetPositions[ix+1] - currentPos[ix+1]) * 0.08;
                    currentPos[ix+2] += (targetPositions[ix+2] - currentPos[ix+2]) * 0.08;
                }
                positionsAttr.needsUpdate = true;

                if(controls.autoRotate) {
                    particles.rotation.y = time * 0.15;
                }
                
                controls.update();
                renderer.render(scene, camera);
            }

            animate();
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        })();
    </script>
</body>
</html>